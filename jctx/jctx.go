// Package jctx implements an encoder and decoder for request context values,
// allowing context metadata to be propagated through JSON-RPC.
//
// A context.Context value carries request-scoped values across API boundaries
// and between processes. The jrpc2 package has hooks to allow clients and
// servers to propagate context values transparently through JSON-RPC calls.
// The jctx package provides functions that implement these hooks.
//
// The jrpc2 context plumbing works by injecting a wrapper message around the
// request parameters. The client adds this wrapper during the call, and the
// server removes it. The actual client parameters are embedded inside the
// wrapper unmodified.
//
// The format of the wrapper generated by this package is:
//
//    {
//      "jctx": "1",
//      "payload":  <original-params>,
//      "deadline": <rfc-3339-timestamp>,
//      "auth":     <opaque-bytes>,
//      "meta":     <json-value>
//    }
//
// Of these, only the "jctx" marker is required; the others are assumed to be
// empty if they do not appear in the message.
//
// Deadlines and Timeouts
//
// If the parent context contains a deadline, it is encoded into the wrapper as
// an RFC 3339 timestamp in UTC, for example "2009-11-10T23:00:00.00000015Z".
//
// Metadata
//
// The jctx.WithMetadata function allows the caller to attach an arbitrary
// JSON-encoded value to a context. This value will be transmitted over the
// wire during a JSON-RPC call. The recipient can decode this value from the
// context using the jctx.UnmarshalMetadata function.
//
// Authorization
//
// The jctx.WithAuthorizer function attaches an Authorizer to a context.  This
// is a function that, when present, is used to generate an authorization token
// for a method and attach that token to the outbound context. After decoding,
// the auth token is available via the jctx.AuthToken helper. The structure of
// an auth token is implementation-defined; it may be JSON or not, but this
// package handles the value as an opaque byte string.
package jctx

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"time"
)

const wireVersion = "1"

// wireContext is the encoded representation of a context value. It includes
// the deadline together with an underlying payload carrying the original
// request parameters. The resulting message replaces the parameters of the
// original JSON-RPC request.
type wireContext struct {
	V string `json:"jctx"` // must be wireVersion

	Deadline *time.Time      `json:"deadline,omitempty"` // encoded in UTC
	Payload  json.RawMessage `json:"payload,omitempty"`
	Token    []byte          `json:"auth,omitempty"`
	Metadata json.RawMessage `json:"meta,omitempty"`
}

// Encode encodes the specified context and request parameters for transmission.
// If a deadline is set on ctx, it is converted to UTC before encoding.
// If metadata are set on ctx (see jctx.WithMetadata), they are included.
// If an authorizer is set on ctx (see jctx.WithAuthorizer), it is invoked and
// the token it returns (if any) is attached.
func Encode(ctx context.Context, method string, params json.RawMessage) (json.RawMessage, error) {
	c := wireContext{V: wireVersion, Payload: params}
	if dl, ok := ctx.Deadline(); ok {
		utcdl := dl.In(time.UTC)
		c.Deadline = &utcdl
	}

	// If there is an authorizer, use it to generate a token for this request.
	if v := ctx.Value(authorizerKey{}); v != nil {
		auth := v.(Authorizer)
		tok, err := auth(ctx, method, []byte(params))
		if err != nil {
			return nil, err
		}
		c.Token = tok
	}

	// If there are metadata in the context, attach them.
	if v := ctx.Value(metadataKey{}); v != nil {
		c.Metadata = v.(json.RawMessage)
	}

	return json.Marshal(c)
}

// Decode decodes the specified request message as a context-wrapped request,
// and returns the updated context (based on ctx) and the embedded parameters.
// If the request does not have a context wrapper, it is returned as-is.
//
// If the encoded request specifies a deadline, that deadline is set in the
// context value returned.
//
// If the request includes context metadata, they are attached and can be
// recovered using jctx.UnmarshalMetadata.
//
// If the request includes an authorization token, it is attached and can be
// recovered using jctx.AuthToken.
func Decode(ctx context.Context, method string, req json.RawMessage) (context.Context, json.RawMessage, error) {
	if len(req) == 0 {
		return ctx, req, nil // an empty message has no wrapper
	}
	var c wireContext
	if err := json.Unmarshal(req, &c); err != nil {
		if _, ok := err.(*json.UnmarshalTypeError); ok {
			return ctx, req, nil // fall back assuming an un-wrapped message
		}
		return nil, nil, err
	} else if c.V != wireVersion {
		return nil, nil, fmt.Errorf("invalid context version %q", c.V)
	}
	if c.Metadata != nil {
		ctx = context.WithValue(ctx, metadataKey{}, c.Metadata)
	}
	if len(c.Token) != 0 {
		ctx = context.WithValue(ctx, authTokenKey{}, c.Token)
	}
	if c.Deadline != nil && !c.Deadline.IsZero() {
		var ignored context.CancelFunc
		ctx, ignored = context.WithDeadline(ctx, (*c.Deadline).In(time.UTC))
		_ = ignored // the caller cannot use this value
	}

	return ctx, c.Payload, nil
}

type metadataKey struct{}

// WithMetadata attaches the specified metadata value to the context.  The meta
// value must support encoding to JSON. In case of error, the original value of
// ctx is returned along with the error.
func WithMetadata(ctx context.Context, meta interface{}) (context.Context, error) {
	bits, err := json.Marshal(meta)
	if err != nil {
		return ctx, err
	}
	return context.WithValue(ctx, metadataKey{}, json.RawMessage(bits)), nil
}

// UnmarshalMetadata decodes the metadata value attached to ctx into meta, or
// returns ErrNoMetadata if ctx does not have metadata attached.
func UnmarshalMetadata(ctx context.Context, meta interface{}) error {
	if v := ctx.Value(metadataKey{}); v != nil {
		return json.Unmarshal(v.(json.RawMessage), meta)
	}
	return ErrNoMetadata
}

// ErrNoMetadata is returned by the Metadata function if the context does not
// contain a metadata value.
var ErrNoMetadata = errors.New("context metadata not present")

type authorizerKey struct{}

// An Authorizer generates an authorization token for a request, given the
// method name and request parameters to be authorized. If the authorizer
// returns an error, context encoding fails. If it returns an empty token
// without error, no token is attached to the context.
type Authorizer func(ctx context.Context, method string, params []byte) ([]byte, error)

// WithAuthorizer attaches the specified authorizer to the context.
func WithAuthorizer(ctx context.Context, auth Authorizer) context.Context {
	return context.WithValue(ctx, authorizerKey{}, auth)
}

type authTokenKey struct{}

// AuthToken reports whether there is an authorization token attached to ctx,
// and if so returns its contents.
func AuthToken(ctx context.Context) ([]byte, bool) {
	if v := ctx.Value(authTokenKey{}); v != nil {
		return v.([]byte), true
	}
	return nil, false
}
